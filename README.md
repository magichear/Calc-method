`2025`春季学期`twh`班计算方法 A 代码实现

我会尽量使用面向对象的思想编辑代码，并加入一些有趣的东西

[TOC]

### Lab 1

> 分别计算级数函数 $\phi = \sum ^{\infty} _{k=1} \dfrac{1}{k(k+x)}$在`x`值为 0.0, 0.5, 1.0, $\sqrt{2}$, 10.0, 100.0, 300.0 时的值，要求误差小于$10^{-6}$

首先使用了暴力算法，穷举指定位数直到基本合格为止

$$1\_000\_000 \ge k \ge  \dfrac{x}{e^{x * 10^{-6}} - 1}$$

不过我这里观察这个最大值达不到要求，再加两个数量级勉强可以，但是这样算会很慢

- 思路一：引入多线程
  - 这里用了`Lambda`
    - 直接在函数内定义，更方便，还能直接用上面定义的变量（可以少传参）
  - 由于我们需要顺序输出，而多线程的返回时间是不确定的，因此要引入锁
    - 同时由于要求顺序，所以这里需要引入`condition_variable`
    - 并且只能使用`unique_lock`
    - 这样可以保证所有线程同时计算，并且按顺序返回
      - 传参中有索引，每个线程结束前会把索引自增，将锁移交给下一个线程
- 思路二：开（去）动（查）脑（资）筋（料）
  - 首先，级数本身可以化简为$ S(x) = \dfrac{1}{x} [ψ(x+1) + γ]$
    - γ 为欧拉-马歇罗尼常数，ψ(x) 为 digamma 函数
    - γ ≈ 0.57721566490153286060651209
  - x=0
    - 巴塞尔问题
    - $result =  \dfrac{\pi ^2 }{ 6}$
  - x=0.5
    - $ψ(0.5 + 1) = -γ - 2ln2 + 2$
    - $result =  4(1-ln2)$
  - x=1
    - 望远镜，展开中间就消掉了（直接返回 1 理论上应该也可以，不过还是做做样子算一下吧）
    - result = 1 - 1/(k+1)
  - x=$\sqrt{2}$
    - result = xxxxxx
    - 由于要求不准调库，这里只能剥蒜
      - 不然`cmath`里就有
      - `java`里的库在`apache`，`py`也有
  - x= n
    - result = $\dfrac{H_n}{n}$
    - 调和级数 $H_n = 1 + 1/2 + 1/3 + ... + 1/n$，n 为正整数
    - 这里可以修改为$$\dfrac{((2+1)*3 + 2*1) + ...}{1*2*3*...*n}$$
      - 首先，整数乘法不会丢精度（只要不溢出），这样我们只会有一步除法需要考虑精度丢失的问题
  - 整体性能瓶颈在于$\sqrt{2}$的爆算，不过问题不是很大，并且我们还有多线程
    - 这就体现出接口设计的重要性了

```
阿祖，都看到这里了，背一下吧：封装、继承、多态
顺便可以看看线程/进程间通信、两者区别（共享堆栈、条件变量、线程安全的队列；管道、消息队列、共享内存、套接字；前者共享资源，开销小速度快|后者开销大但更安全。适用场景不同），
以及线程池的关键参数及其意义（核心/最大线程数、任务队列、存活时间、拒绝策略、线程工厂, etc）
还有两种锁的区别和 emplace_back 跟 push_back 在构造上的区别
```

另外，老师第一周讲了误差分析，给了几个公式，但是似乎没讲误差传播公式（也可能是我没听（

如果 $ z $ 是 $ x $ 和 $ y $ 的函数，那么 $ z $ 的误差可以通过对 $ x $ 和 $ y $ 的偏导数来近似计算： $ e(z) \approx \left| \frac{\partial z}{\partial x} \right| e(x) + \left| \frac{\partial z}{\partial y} \right| e(y) $

有了这个公式再算是不是就很简单了：$ e\left( \frac{x}{y} \right) \approx \left| \frac{1}{y} \right| e(x) + \left| -\frac{x}{y^2} \right| e(y) $

相应的，相对误差也可以代公式（x+y 看成一个整体）

$$
\begin{aligned}
e_r(x + y) \approx& \dfrac{e(x+y)}{x+y} \approx \dfrac{1·x · e(x)/x + 1·y · e(y)/y}{x+y}\\
\approx&\frac{x e_r(x) + y e_r(y)}{|x + y|}  记住这个绝对值
\end{aligned}
$$

对于乘法和除法（自己算哦）：

$$
e_r(x \cdot y) \approx e_r(x) + e_r(y)
$$

$$
e_r\left(\frac{x}{y}\right) \approx e_r(x) - e_r(y)
$$

### Lab4

定义了一个求解器接口，要求实现类完成`compute`方法计算积分近似结果

积分制和误差的计算都好说

- 复化梯形积分 $\dfrac{h}{2} [ f(a) + 2 \sum ^{n-1} _{i=1} f(x_i) + f(b) ]$
- 复化`Simpson`积分：$\dfrac{h}{3} [ f(a) + 4 \sum ^{n-1} _{i=1,3,5...} f(x_{i}) + 2 \sum ^{n-2} _{i=2,4,6...} f(x_{i}) + f(b) ]$

另外，由于每一组的节点数相较于上一组都相当于倍增，因此步长可以相应的近似看作减半（本次只需要求`k=2`的情况）

需要注意的是，`double`的精度不够，会导致`Simpson`误差阶的最后几组出错

```sh
double:
0.256640121764800       0.000000001359887       4.000126622110034
0.256640120489899       0.000000000084985       3.999986807224332
0.256640120410225       0.000000000005312       3.997198327796937
0.256640120405246       0.000000000000333       4.025259952401738
0.256640120404934       0.000000000000020       2.569365645670138
0.256640120404917       0.000000000000003
long double:
0.256640121764800       0.000000001359886       4.000126843042480
0.256640120489899       0.000000000084985       4.000048347110856
0.256640120410225       0.000000000005311       4.000276930941804
0.256640120405245       0.000000000000332       4.004338633367542
0.256640120404934       0.000000000000021       4.070588253176797
0.256640120404915       0.000000000000001
```

可以看到`double`那里出现了震荡
下面是完整的测试结果

```sh
                Exact Value: 0.256640120404914
Trapezoidal Integral:
Integral Value          Error                   Error Order
0.164786726264492       0.091853394140421       2.078196532702628
0.234888294650000       0.021751825754914       2.018389584797537
0.251271040001647       0.005369080403267       2.004530334299437
0.255302058674164       0.001338061730749       2.001128469941994
0.256305866526472       0.000334253878441       2.000281861572963
0.256556573259633       0.000083547145280       2.000070449414101
0.256619234638508       0.000020885766405       2.000017611342552
0.256634899027051       0.000005221377862       2.000004402721330
0.256638815064432       0.000001305340482       2.000001100469075
0.256639794070042       0.000000326334872       2.000000274308840
0.256640038821211       0.000000081583702       2.000000065323026
0.256640100008989       0.000000020395925       None

Simpson Integral:
Integral Value          Error                   Error Order
0.298017828256151       0.041377707851238       4.678922791905884
0.258255484111835       0.001615363706922       4.136675618834669
0.256731955118863       0.000091834713949       4.032668622758138
0.256645731565003       0.000005611160090       4.008079479381431
0.256640469143908       0.000000348738995       4.002014482080105
0.256640142170687       0.000000021765774       4.000503349489247
0.256640121764800       0.000000001359886       4.000126843042480
0.256640120489899       0.000000000084985       4.000048347110856
0.256640120410225       0.000000000005311       4.000276930941804
0.256640120405245       0.000000000000332       4.004338633367542
0.256640120404934       0.000000000000021       4.070588253176797
0.256640120404915       0.000000000000001       None
```
